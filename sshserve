#!/usr/bin/env python3
import json
import os
import re
import shutil
import sys
from pathlib import Path


SCRIPT_PATH = Path(__file__).resolve()
DATA_PATH = SCRIPT_PATH.with_name("sshserve_connections.json")
NAME_RE = re.compile(r"^[A-Za-z0-9_.-]+$")


def fail(message: str, code: int = 1) -> None:
    print(f"Error: {message}", file=sys.stderr)
    sys.exit(code)


def usage() -> None:
    print(
        "Usage:\n"
        "  sshserve add <name> <user@host>\n"
        "  sshserve list\n"
        "  sshserve remove <name>\n"
        "  sshserve update <name> <user@host>\n"
        "  sshserve <name>\n"
    )


def validate_name(name: str) -> None:
    if not NAME_RE.match(name):
        fail("Invalid name. Use only letters, numbers, dot, underscore, or dash.")


def validate_target(target: str) -> None:
    if any(ch.isspace() for ch in target):
        fail("Invalid target format. Use: user@host")
    if target.count("@") != 1:
        fail("Invalid target format. Use: user@host")
    user, host = target.split("@", 1)
    if not user or not host:
        fail("Invalid target format. Use: user@host")


def write_store(data: dict) -> None:
    tmp_path = DATA_PATH.with_suffix(DATA_PATH.suffix + ".tmp")
    with tmp_path.open("w", encoding="utf-8") as file:
        json.dump(data, file, indent=2, ensure_ascii=True, sort_keys=True)
        file.write("\n")
    os.chmod(tmp_path, 0o600)
    os.replace(tmp_path, DATA_PATH)
    os.chmod(DATA_PATH, 0o600)


def ensure_store() -> dict:
    if not DATA_PATH.exists():
        data = {"connections": {}}
        write_store(data)
        return data

    try:
        with DATA_PATH.open("r", encoding="utf-8") as file:
            data = json.load(file)
    except json.JSONDecodeError:
        fail(f"Invalid JSON in storage file: {DATA_PATH}")
    except OSError as err:
        fail(f"Unable to read storage file {DATA_PATH}: {err}")

    if not isinstance(data, dict) or not isinstance(data.get("connections"), dict):
        fail(f"Invalid storage structure in {DATA_PATH}")

    for key, value in data["connections"].items():
        if not isinstance(key, str) or not isinstance(value, str):
            fail(f"Invalid storage structure in {DATA_PATH}")

    try:
        os.chmod(DATA_PATH, 0o600)
    except OSError:
        pass

    return data


def cmd_add(name: str, target: str) -> None:
    validate_name(name)
    validate_target(target)
    data = ensure_store()
    connections = data["connections"]
    if name in connections:
        fail("Connection already exists. Use another name or run update.")
    connections[name] = target
    write_store(data)
    print(f"Added: {name} -> {target}")


def cmd_list() -> None:
    data = ensure_store()
    connections = data["connections"]
    if not connections:
        print("No connections saved.")
        return
    for name in sorted(connections):
        print(f"{name}\t{connections[name]}")


def cmd_remove(name: str) -> None:
    validate_name(name)
    data = ensure_store()
    connections = data["connections"]
    if name not in connections:
        fail("Connection not found.")
    del connections[name]
    write_store(data)
    print(f"Removed: {name}")


def cmd_update(name: str, target: str) -> None:
    validate_name(name)
    validate_target(target)
    data = ensure_store()
    connections = data["connections"]
    if name not in connections:
        fail("Connection not found. Use add to create it.")
    connections[name] = target
    write_store(data)
    print(f"Updated: {name} -> {target}")


def cmd_connect(name: str) -> None:
    validate_name(name)
    data = ensure_store()
    target = data["connections"].get(name)
    if target is None:
        fail("Connection not found.")
    if shutil.which("ssh") is None:
        fail("ssh command not found in PATH.")
    os.execvp("ssh", ["ssh", target])


def main(argv: list[str]) -> int:
    if len(argv) < 2:
        usage()
        return 1

    command = argv[1]
    if command in ("-h", "--help", "help"):
        usage()
        return 0

    if command == "add":
        if len(argv) != 4:
            usage()
            return 1
        cmd_add(argv[2], argv[3])
        return 0

    if command == "list":
        if len(argv) != 2:
            usage()
            return 1
        cmd_list()
        return 0

    if command == "remove":
        if len(argv) != 3:
            usage()
            return 1
        cmd_remove(argv[2])
        return 0

    if command == "update":
        if len(argv) != 4:
            usage()
            return 1
        cmd_update(argv[2], argv[3])
        return 0

    if len(argv) != 2:
        usage()
        return 1
    cmd_connect(command)
    return 0


if __name__ == "__main__":
    sys.exit(main(sys.argv))
